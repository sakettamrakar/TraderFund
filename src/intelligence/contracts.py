from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
from datetime import datetime

@dataclass(frozen=True)
class ResearchOverlay:
    """
    Contextual overlay from the Research Layer.
    Explains whether this attention signal is interesting or dangerous
    according to the current Regime/Factor models.
    """
    status: str  # "ALLOWED", "BLOCKED", "CAUTION"
    reason: str  # e.g., "Regime matches", "Blocked by Low Momentum"
    regime: str  # Current regime context
    
@dataclass(frozen=True)
class AttentionSignal:
    """
    A raw attention signal generated by a heuristic.
    Does NOT imply trade execution.
    """
    symbol: str
    signal_type: str        # e.g., "VOLATILITY_EXPANSION"
    
    # Semantic Fields (Strict)
    domain: str             # "PRICE", "VOLATILITY", "VOLUME"
    metric_label: str       # e.g. "20d Volatility"
    metric_value: float     # The raw value
    unit: str               # "%", "x", "Ïƒ", "$"
    baseline: str           # e.g. "vs 20d Avg (2.0)"
    
    reason: str             # Human readable summary (Legacy/Display)
    
    explanation: Dict[str, str] # { "what": "...", "why": "...", "not": "..." }
    
    timestamp: str          # ISO timestamp
    market: str             # "US" or "INDIA"
    
    # Context overlay (populated by Engine, not Generator)
    overlay: Optional[ResearchOverlay] = None

@dataclass
class IntelligenceSnapshot:
    """
    Daily snapshot of all attention signals for a specific market.
    """
    timestamp: str
    market: str
    signals: List[AttentionSignal] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp,
            "market": self.market,
            "metadata": self.metadata,
            "signals": [
                {
                    "symbol": s.symbol,
                    "type": s.signal_type,
                    "domain": s.domain,
                    "metric_label": s.metric_label,
                    "metric": s.metric_value,
                    "unit": s.unit,
                    "baseline": s.baseline,
                    "reason": s.reason,
                    "explanation": s.explanation,
                    "overlay": {
                        "status": s.overlay.status,
                        "reason": s.overlay.reason,
                        "regime": s.overlay.regime
                    } if s.overlay else None
                }
                for s in self.signals
            ]
        }
